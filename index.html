<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attention is Soft KNN</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate 900 */
            color: #f8fafc;
        }
        .mono {
            font-family: 'JetBrains Mono', monospace;
        }
        .glass {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .glass-purple {
            background: rgba(88, 28, 135, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(168, 85, 247, 0.3);
        }
        canvas {
            touch-action: none; /* Prevent scrolling while dragging on canvas */
        }
        /* Custom scrollbar for AI response */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .shimmer {
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0) 100%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- Title Section -->
    <div class="max-w-5xl mx-auto px-6 pt-10 pb-6">
        <h1 class="text-4xl font-bold text-white mb-2 tracking-tight">
            <span class="text-blue-500">Attention</span> is Soft <span class="text-green-400">KNN</span>
        </h1>
        <p class="text-slate-400 text-lg">
            Visualizing the explicit mathematical equivalence between Transformer Attention and Nadaraya-Watson Kernel Regression.
        </p>
    </div>

    <!-- Visualization Section (Moved to Top) -->
    <div id="app-container" class="max-w-5xl mx-auto px-6 pb-12 min-h-[700px]">
        <div class="glass rounded-xl p-1 relative">
            <canvas id="attnCanvas" class="w-full h-[600px] rounded-lg cursor-crosshair bg-slate-900"></canvas>
            
            <!-- Floating UI Overlay -->
            <div class="absolute top-4 left-4 p-4 glass rounded-lg max-w-xs pointer-events-none">
                <div class="text-xs uppercase tracking-wider text-slate-400 mb-2">Attention Weights (Softmax)</div>
                <div id="weights-display" class="space-y-1 font-mono text-sm">
                    <!-- Javascript will populate this -->
                </div>
            </div>
            
            <div class="absolute bottom-4 left-4 text-slate-400 text-xs pointer-events-none">
                Drag the white ring (Query) to see how it absorbs colors (Values) from nearby keys.
            </div>
        </div>
    </div>

    <!-- Explanatory Content (Moved Below) -->
    <div class="max-w-5xl mx-auto px-6 pb-16">
        <div class="grid md:grid-cols-2 gap-8 mb-8">
            <!-- KNN Side -->
            <div class="space-y-4">
                <h3 class="flex items-center gap-2 text-green-400 font-semibold uppercase tracking-wider text-sm">
                    <span class="material-symbols-outlined">dataset</span> Kernel Regression (1964)
                </h3>
                <div class="glass rounded-lg p-4 font-serif text-lg text-center overflow-x-auto">
                    $$y = \frac{\sum K(x, x_i)y_i}{\sum K(x, x_i)}$$
                </div>
                <p class="text-sm text-slate-400 leading-relaxed">
                    To predict the value ($y$) for a query point ($x$), we look at all training points ($x_i$). 
                    We calculate a similarity weight $K(x, x_i)$ for each. 
                    The result is a <b>weighted average</b> of their known values ($y_i$).
                </p>
            </div>

            <!-- Attention Side -->
            <div class="space-y-4">
                <h3 class="flex items-center gap-2 text-blue-400 font-semibold uppercase tracking-wider text-sm">
                    <span class="material-symbols-outlined">smart_toy</span> Transformer Attention (2017)
                </h3>
                <div class="glass rounded-lg p-4 font-serif text-lg text-center overflow-x-auto">
                    $$\text{Attn}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d}}\right)V$$
                </div>
                <p class="text-sm text-slate-400 leading-relaxed">
                    To find the Context ($Z$) for a Query ($Q$), we compare it against all Keys ($K$).
                    The dot product $QK^T$ is the similarity kernel. 
                    Softmax normalizes these weights (just like the denominator in regression).
                    We then sum the Values ($V$).
                </p>
            </div>
        </div>

        <!-- The Mapping Table -->
        <div class="glass rounded-xl p-6 overflow-hidden mb-8">
            <h4 class="text-center text-xs font-bold text-white mb-6 uppercase tracking-widest opacity-60">The Dictionary</h4>
            
            <div class="grid grid-cols-4 gap-4 text-xs font-bold uppercase tracking-wider text-slate-500 border-b border-slate-700 pb-2 mb-2">
                <div>Concept</div>
                <div>Regression Term</div>
                <div>Attention Term</div>
                <div>In Visualizer</div>
            </div>
            
            <!-- Row 1 -->
            <div class="grid grid-cols-4 gap-4 text-sm items-center py-3 border-b border-slate-700/50">
                <div class="font-semibold text-white">Search Input</div>
                <div class="mono text-green-300">Target \(x\)</div>
                <div class="mono text-blue-300">Query \(Q\)</div>
                <div class="flex items-center gap-2 text-slate-300"><span class="w-3 h-3 rounded-full border-2 border-white bg-transparent"></span> Draggable Ring</div>
            </div>
            <!-- Row 2 -->
            <div class="grid grid-cols-4 gap-4 text-sm items-center py-3 border-b border-slate-700/50">
                <div class="font-semibold text-white">Database</div>
                <div class="mono text-green-300">Examples \(x_i\)</div>
                <div class="mono text-blue-300">Keys \(K\)</div>
                <div class="flex items-center gap-2 text-slate-300"><span class="w-2 h-2 rounded-full bg-slate-500"></span> Fixed Dots</div>
            </div>
            <!-- Row 3 -->
            <div class="grid grid-cols-4 gap-4 text-sm items-center py-3 border-b border-slate-700/50">
                <div class="font-semibold text-white">Content</div>
                <div class="mono text-green-300">Labels \(y_i\)</div>
                <div class="mono text-blue-300">Values \(V\)</div>
                <div class="flex items-center gap-2 text-slate-300"><span class="w-3 h-3 rounded bg-gradient-to-r from-red-500 to-blue-500"></span> Dot Colors</div>
            </div>
             <!-- Row 4 -->
             <div class="grid grid-cols-4 gap-4 text-sm items-center py-3">
                <div class="font-semibold text-white">Result</div>
                <div class="mono text-green-300">Smoothed \(y\)</div>
                <div class="mono text-blue-300">Context \(Z\)</div>
                <div class="flex items-center gap-2 text-slate-300">Ring Fill Color</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('attnCanvas');
        const ctx = canvas.getContext('2d');
        const weightsDisplay = document.getElementById('weights-display');
        const aiResponseArea = document.getElementById('ai-response-area');
        
        // --- Gemini API Setup ---
        const apiKey = ""; // Injected by environment
        let isGenerating = false;

        async function callGemini(prompt) {
            if (isGenerating) return;
            isGenerating = true;
            
            // Show loading state
            const originalContent = aiResponseArea.innerHTML;
            aiResponseArea.innerHTML = `
                <div class="space-y-2 animate-pulse">
                    <div class="h-2 bg-purple-500/20 rounded w-3/4"></div>
                    <div class="h-2 bg-purple-500/20 rounded w-1/2"></div>
                    <div class="h-2 bg-purple-500/20 rounded w-full"></div>
                </div>
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) throw new Error('API Request failed');

                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;
                
                // Render Markdown-ish text
                aiResponseArea.innerHTML = marked.parse(text);
                
            } catch (error) {
                console.error(error);
                aiResponseArea.innerHTML = `<span class="text-red-400">Error: Could not reach Gemini. Please try again.</span>`;
            } finally {
                isGenerating = false;
            }
        }

        function analyzeState() {
            // 1. Gather Data
            const weights = currentWeights || [];
            // Sort to find dominant keys
            const sorted = weights.map((w, i) => ({ w, i, color: keys[i].colorName })).sort((a, b) => b.w - a.w);
            const topMatch = sorted[0];
            const isPeaked = topMatch.w > 0.8;
            const isUniform = topMatch.w < 0.25;

            // 2. Construct Prompt
            let contextDesc = `
            You are an AI tutor explaining Transformer Attention. The user is interacting with a visualization where "Attention is Soft KNN".
            
            Current State Data:
            - The Query vector is positioned such that the highest attention weight is ${(topMatch.w * 100).toFixed(1)}% on a ${topMatch.color} Key.
            - The distribution is ${isPeaked ? "highly peaked (Low Entropy)" : (isUniform ? "very diffuse (High Entropy)" : "mixed")}.
            `;

            if (isPeaked) {
                contextDesc += `Explain that this is "Hard Attention". The model is effectively "copying" information from a single specific memory (the ${topMatch.color} key). This is useful for precise lookup.`;
            } else if (isUniform) {
                contextDesc += `Explain that this is "High Entropy" attention. The query is confused or unrelated to all keys, so it's averaging everything. The context vector is a muddy mix.`;
            } else {
                contextDesc += `Explain that the model is "mixing concepts". It's retrieving a blend of information, primarily from the ${topMatch.color} key but with significant influence from others. This creates a nuanced representation.`;
            }

            const prompt = `${contextDesc}
            
            Task: Write a short, insightful, 2-paragraph explanation of what this state represents in a real Neural Network. Use 2nd person ("You are..."). Be encouraging.`;

            callGemini(prompt);
        }

        function generateAnalogy() {
            const prompt = `
            Generate a creative, unique analogy to explain the concept of "Attention mechanisms are just weighted averages (Kernel Regression)".
            
            Do NOT use the standard "Database Lookup" or "Filing Cabinet" analogy.
            
            Try metaphors like:
            - Social dynamics (listening to voices in a crowd)
            - Cooking (blending flavors)
            - Lighting (spotlights)
            - Gravity/Orbit
            
            Keep it under 3 sentences. Make it fun and clear for a student. Start with "Imagine..."
            `;
            callGemini(prompt);
        }

        // --- Visualization Logic ---
        let width, height;
        const keys = [];
        let query = { x: 0, y: 0, color: 'white', radius: 15, isDragging: false };
        let currentWeights = []; // Store for AI access
        
        // Configuration
        const keyCount = 7;
        const kernelScale = 0.0001; 

        // Colors for Values (V)
        const colors = [
            { r: 239, g: 68, b: 68, name: 'Red' },   
            { r: 59, g: 130, b: 246, name: 'Blue' },  
            { r: 34, g: 197, b: 94, name: 'Green' },   
            { r: 234, g: 179, b: 8, name: 'Yellow' },   
            { r: 168, g: 85, b: 247, name: 'Purple' },  
            { r: 236, g: 72, b: 153, name: 'Pink' },  
            { r: 14, g: 165, b: 233, name: 'Sky' }   
        ];

        function resize() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth * window.devicePixelRatio;
            canvas.height = container.clientHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            width = container.clientWidth;
            height = container.clientHeight;
            
            if (keys.length === 0) initKeys();
            if (query.x === 0) {
                query.x = width / 2;
                query.y = height / 2;
            }
        }

        function initKeys() {
            keys.length = 0;
            for (let i = 0; i < keyCount; i++) {
                const colorObj = colors[i % colors.length];
                keys.push({
                    x: Math.random() * (width - 100) + 50,
                    y: Math.random() * (height - 100) + 50,
                    color: colorObj,
                    colorName: colorObj.name,
                    radius: 8,
                    id: i
                });
            }
        }

        function getDistanceSq(p1, p2) {
            return (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2;
        }

        function update() {
            let rawWeights = keys.map(k => {
                const distSq = getDistanceSq(query, k);
                return Math.exp(-distSq * kernelScale);
            });

            const sumWeights = rawWeights.reduce((a, b) => a + b, 0);
            const normalizedWeights = rawWeights.map(w => w / sumWeights);
            currentWeights = normalizedWeights;

            let r = 0, g = 0, b = 0;
            normalizedWeights.forEach((w, i) => {
                r += keys[i].color.r * w;
                g += keys[i].color.g * w;
                b += keys[i].color.b * w;
            });
            
            query.color = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;

            draw(normalizedWeights);
            updateUI(normalizedWeights);
            requestAnimationFrame(update);
        }

        function draw(weights) {
            ctx.clearRect(0, 0, width, height);

            // Draw Connections
            keys.forEach((k, i) => {
                const weight = weights[i];
                if (weight > 0.01) {
                    ctx.beginPath();
                    ctx.moveTo(query.x, query.y);
                    ctx.lineTo(k.x, k.y);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${weight})`;
                    ctx.lineWidth = weight * 8;
                    ctx.stroke();
                }
            });

            // Draw Keys
            keys.forEach(k => {
                ctx.beginPath();
                ctx.arc(k.x, k.y, k.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${k.color.r},${k.color.g},${k.color.b})`;
                ctx.fill();
                ctx.shadowBlur = 10;
                ctx.shadowColor = `rgb(${k.color.r},${k.color.g},${k.color.b})`;
                ctx.stroke();
                ctx.shadowBlur = 0;
            });

            // Draw Query
            ctx.beginPath();
            ctx.arc(query.x, query.y, query.radius, 0, Math.PI * 2);
            ctx.fillStyle = query.color;
            ctx.fill();
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'white';
            ctx.stroke();
            
            ctx.fillStyle = 'white';
            ctx.font = '12px Inter';
            ctx.fillText("Q", query.x - 5, query.y + 4);
        }

        function updateUI(weights) {
            let html = '';
            const indices = weights.map((w, i) => ({w, i})).sort((a, b) => b.w - a.w);
            
            indices.forEach(item => {
                const k = keys[item.i];
                const pct = (item.w * 100).toFixed(1);
                if (item.w > 0.01) {
                    const colorHex = `rgb(${k.color.r},${k.color.g},${k.color.b})`;
                    html += `
                        <div class="flex items-center justify-between gap-4">
                            <div class="flex items-center gap-2">
                                <span class="w-2 h-2 rounded-full" style="background-color: ${colorHex}"></span>
                                <span class="text-slate-300">Key ${item.i}</span>
                            </div>
                            <div class="text-right font-bold" style="color: ${colorHex}">${pct}%</div>
                        </div>
                        <div class="w-full bg-slate-700 h-1 rounded-full mt-1 mb-2">
                            <div class="h-full rounded-full" style="width: ${pct}%; background-color: ${colorHex}"></div>
                        </div>
                    `;
                }
            });
            weightsDisplay.innerHTML = html;
        }

        // Interaction Handlers
        function handleStart(x, y) {
            const dx = x - query.x;
            const dy = y - query.y;
            if (dx*dx + dy*dy < (query.radius + 20)**2) {
                query.isDragging = true;
            }
        }

        function handleMove(x, y) {
            if (query.isDragging) {
                query.x = x;
                query.y = y;
                
                if(query.x < 0) query.x = 0;
                if(query.x > width) query.x = width;
                if(query.y < 0) query.y = 0;
                if(query.y > height) query.y = height;
            }
        }

        function handleEnd() {
            query.isDragging = false;
        }

        canvas.addEventListener('mousedown', e => {
            const rect = canvas.getBoundingClientRect();
            handleStart(e.clientX - rect.left, e.clientY - rect.top);
        });
        window.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            handleMove(e.clientX - rect.left, e.clientY - rect.top);
        });
        window.addEventListener('mouseup', handleEnd);

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            handleStart(touch.clientX - rect.left, touch.clientY - rect.top);
        }, {passive: false});
        
        window.addEventListener('touchmove', e => {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            handleMove(touch.clientX - rect.left, touch.clientY - rect.top);
        }, {passive: false});
        
        window.addEventListener('touchend', handleEnd);

        window.addEventListener('resize', resize);
        // Initial setup
        setTimeout(() => {
            resize();
            update();
        }, 100);

    </script>
</body>
</html>
